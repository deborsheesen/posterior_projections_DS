}
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
# Total matrix A
A <- rbind(E, IE)
## Solver
Dmat <- diag(length(X))
dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
solve.QP(Dmat, dvec, Amat, bvec)
install.packages("quadprog")
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
A <- rbind(E, IE)
Dmat <- diag(length(X))
dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
solve.QP(Dmat, dvec, Amat, bvec)
X <- c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data <- matrix(X, 4,5)
a <- 1 # alpha
# Number of samples
N <- 10000
## Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean <- apply(piPrior,1:2, mean)
piPriorCum <- t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
## Projected probability
piPriorProj <- array(0,dim=c(4,5,N))
distPrior <- double(N)
for (n in 1:N){
temp <- c(piPrior[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] <- matrix(sol,4,5)
distPrior[n] <- norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
# Total matrix A
A <- rbind(E, IE)
## Data
X <- c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data <- matrix(X, 4,5)
a <- 1 # alpha
# Number of samples
N <- 10000
## Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean <- apply(piPrior,1:2, mean)
piPriorCum <- t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
## Projected probability
piPriorProj <- array(0,dim=c(4,5,N))
distPrior <- double(N)
for (n in 1:N){
temp <- c(piPrior[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] <- matrix(sol,4,5)
distPrior[n] <- norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
## Posterior
piPost <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPost[i,,] <- t(rDirichlet(N, alpha = (data[i,]+a)))
}
piPostMean <- apply(piPost,1:2, mean)
piPostCum <- t(apply(matrix(piPostMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
# Total matrix A
A <- rbind(E, IE)
## Data
X <- c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data <- matrix(X, 4,5)
a <- 1 # alpha
# Number of samples
N <- 10000
## Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean <- apply(piPrior,1:2, mean)
piPriorCum <- t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
## Solver
Dmat <- diag(length(X))
dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
solve.QP(Dmat, dvec, Amat, bvec)
## Projected probability
piPriorProj <- array(0,dim=c(4,5,N))
distPrior <- double(N)
for (n in 1:N){
temp <- c(piPrior[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] <- matrix(sol,4,5)
distPrior[n] <- norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
## Posterior
piPost <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPost[i,,] <- t(rDirichlet(N, alpha = (data[i,]+a)))
}
piPostMean <- apply(piPost,1:2, mean)
piPostCum <- t(apply(matrix(piPostMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
## Projected probability
piPostProj <- array(0,dim=c(4,5,N))
distPost <- double(N)
for (n in 1:N){
temp <- c(piPost[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPostProj[,,n] <- matrix(sol,4,5)
distPost[n] <- norm(piPost[,,n]-piPostProj[,,n], type = "F")
}
piPostProjMean <- apply(piPostProj, 1:2, mean)
piPostProjLow <- apply(piPostProj, 1:2, function(i)quantile(i, probs = c(.025)))
piPostProjHigh <- apply(piPostProj, 1:2, function(i)quantile(i, probs = c(.975)))
piPostProjCum <- t(apply(matrix(piPostProjMean,4, 5), 1, cumsum)) # Sanity check: Last column is 1
CUPost <- array(0, dim=c(3,4,N))
for (n in 1:N){
tempCU <- t(apply(piPost[,,n], 1, cumsum))
for(i in 1:3){
CUPost[i,,n] <- tempCU[i,1:4]/tempCU[(i+1),1:4]
}
}
CUPostMean <- apply(CUPost, 1:2, mean)
CUPostLow <- apply(CUPost, 1:2, function(i)quantile(i, probs = c(.025)))
CUPostHigh <- apply(CUPost, 1:2, function(i)quantile(i, probs = c(.975)))
# Projected CU
CUPostProj <- array(0, dim=c(3,4,N))
for (n in 1:N){
tempCU <- t(apply(piPostProj[,,n], 1, cumsum))
for(i in 1:3){
CUPostProj[i,,n] <- tempCU[i,1:4]/tempCU[(i+1),1:4]
}
}
CUPostProjMean <- apply(CUPostProj, 1:2, mean)
CUPostProjLow <- apply(CUPostProj, 1:2, function(i)quantile(i, probs = c(.025)))
CUPostProjHigh <- apply(CUPostProj, 1:2, function(i)quantile(i, probs = c(.975)))
Alpha <- c(0.1, 0.5, 1, 5, 10)
distPriorMean = distPostMean = double(length(Alpha))
count <- 1
for (a in Alpha){
print(a)
N <- 10000
# Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
## Projected probability
piPriorProj <- array(0,dim=c(4,5,N))
distPrior <- double(N)
for (n in 1:N){
temp <- c(piPrior[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] <- matrix(sol,4,5)
distPrior[n] <- norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
distPriorMean[count] <- mean(distPrior)
# Posterior
piPost <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPost[i,,] <- t(rDirichlet(N, alpha = (data[i,]+a)))
}
## Projected probability
piPostProj <- array(0,dim=c(4,5,N))
distPost <- double(N)
for (n in 1:N){
temp <- c(piPost[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPostProj[,,n] <- matrix(sol,4,5)
distPost[n] <- norm(piPost[,,n]-piPostProj[,,n], type = "F")
}
distPostMean[count] <- mean(distPost)
count <- count + 1
}
plot(Alpha, distPriorMean, type="l", col="red", lwd = 3)
lines(Alpha, distPostMean, col="green", lwd = 3)
legend("topright", c("Prior", "Posterior"), lty = c(1,1), lwd = c(3,3), col=c("red","green"))
plot(ecdf(distPrior), col = "red", lwd = 3, lty = 1, main = "", xlab ="", ylab = "")
lines(ecdf(distPost), col = "green", lwd = 3, lty = 1)
legend("bottomright", c("Prior", "Posterior"), lty = c(1,1), lwd = c(3,3), col=c("red","green"))
mean(distPost)
mean(distPrior)
BF <- function(t){
priort <- sum(distPrior <= sqrt(t))
priorRatio <- priort/(N-priort)
postt <- sum(distPost <= sqrt(t))
postRatio <- postt/(N-postt)
return(postRatio/priorRatio)
}
BF(0.005)
plot(1:N, distPrior)
plot(1:N, distPost)
quantile(distPrior, probs = c(.05,.1,.25,.5,.75,.90,.95))
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
## Data
X <- c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data <- matrix(X, 4,5)
a <- 1 # alpha
# Number of samples
N <- 10000
## Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean <- apply(piPrior,1:2, mean)
piPriorCum <- t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
Dmat <- diag(length(X))
dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
solve.QP(Dmat, dvec, Amat, bvec)
library(quadprog)
rDirichlet <- function(n, alpha){
l <- length(alpha)
x <- matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm <- rowSums(x)
return(x/sm)
}
# Projection
# Equality restriction matrix E
E <- matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] <- 1
}
# Inequality restriction matrix IE
IE <- matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m <- matrix(0,4,5)
m[i,1:j] <- 1
m[(i+1),1:j] <- -1
ind <- 5*(i-1)+j
IE[ind,] <- c(m)
}
}
# Total matrix A
A <- rbind(E, IE)
## Data
X <- c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data <- matrix(X, 4,5)
a <- 1 # alpha
# Number of samples
N <- 10000
## Prior
piPrior <- array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] <- t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean <- apply(piPrior,1:2, mean)
piPriorCum <- t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
## Solver
Dmat <- diag(length(X))
dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
solve.QP(Dmat, dvec, Amat, bvec)
Dmat <- diag(length(X))
#dvec <- piPostMean
Amat <- t(A)
bvec <- c(rep(1,4),rep(0,15))
#solve.QP(Dmat, dvec, Amat, bvec)
piPriorProj <- array(0,dim=c(4,5,N))
distPrior <- double(N)
for (n in 1:N){
temp <- c(piPrior[,,n])
sol <- solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] <- matrix(sol,4,5)
distPrior[n] <- norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
a=1
a
library(quadprog)
rDirichlet = function(n, alpha){
l = length(alpha)
x = matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm = rowSums(x)
return(x/sm)
}
# Equality restriction matrix E
E = matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] = 1
}
# Inequality restriction matrix IE
IE = matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m = matrix(0,4,5)
m[i,1:j] = 1
m[(i+1),1:j] = -1
ind = 5*(i-1)+j
IE[ind,] = c(m)
}
}
# Total matrix A
A = rbind(E, IE)
## Data
X = c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data = matrix(X, 4,5)
a = 1 # alpha
# Number of samples
N = 10000
## Generate samples from prior:
piPrior = array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] = t(rDirichlet(N, alpha = rep(a,5)))
}
piPriorMean = apply(piPrior,1:2, mean)
piPriorCum = t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
# Project prior samples
piPriorProj = array(0,dim=c(4,5,N))
distPrior = double(N)
for (n in 1:N){
temp = c(piPrior[,,n])
sol = solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] = matrix(sol,4,5)
distPrior[n] = norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
library(quadprog)
rDirichlet = function(n, alpha){
l = length(alpha)
x = matrix(rgamma(l * n, alpha), ncol = l, byrow = TRUE)
sm = rowSums(x)
return(x/sm)
}
# Equality restriction matrix E
E = matrix(0,4,20)
for (i in 1:4){
E[i,seq(i,20,4)] = 1
}
# Inequality restriction matrix IE
IE = matrix(0,15,20)
for (i in 1:3){
for (j in 1:5){
m = matrix(0,4,5)
m[i,1:j] = 1
m[(i+1),1:j] = -1
ind = 5*(i-1)+j
IE[ind,] = c(m)
}
}
# Total matrix A
A = rbind(E, IE)
## Data
X = c(59,48,44,43,25,21,14,4,46,44,54,49,48,47,64,58,32,30,31,41)
data = matrix(X, 4,5)
a = 1 # alpha
## Solver basics:
Dmat = diag(length(X))
Amat = t(A)
bvec = c(rep(1,4),rep(0,15))
# Number of samples
N = 10000
## Generate samples from prior:
piPrior = array(0,dim=c(4,5,N))
for (i in 1:4){
piPrior[i,,] = t(rDirichlet(N, alpha = rep(a,5)))
}
# Find prior mean:
piPriorMean = apply(piPrior,1:2, mean)
piPriorCum = t(apply(matrix(piPriorMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
# Project prior samples
piPriorProj = array(0,dim=c(4,5,N))
distPrior = double(N)
for (n in 1:N){
temp = c(piPrior[,,n])
sol = solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPriorProj[,,n] = matrix(sol,4,5)
distPrior[n] = norm(piPrior[,,n]-piPriorProj[,,n], type = "F")
}
## Generate samples from posterior:
piPost = array(0,dim=c(4,5,N))
for (i in 1:4){
piPost[i,,] = t(rDirichlet(N, alpha = (data[i,]+a)))
}
piPostMean = apply(piPost,1:2, mean)
piPostCum = t(apply(matrix(piPostMean, 4, 5), 1, cumsum)) # Sanity check: Last column is 1
# Project posterior samples:
piPostProj = array(0,dim=c(4,5,N))
distPost = double(N)
for (n in 1:N){
temp = c(piPost[,,n])
sol = solve.QP(Dmat, temp, Amat, bvec, meq = 4)$solution
piPostProj[,,n] = matrix(sol,4,5)
distPost[n] = norm(piPost[,,n]-piPostProj[,,n], type = "F")
}
piPostProjMean = apply(piPostProj, 1:2, mean)
piPostProjLow = apply(piPostProj, 1:2, function(i)quantile(i, probs = c(.025)))
piPostProjHigh = apply(piPostProj, 1:2, function(i)quantile(i, probs = c(.975)))
